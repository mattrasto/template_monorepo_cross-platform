import { Op } from 'sequelize';
import { models } from '@database';
import { logError } from '@logging';
import { ensureJSON } from '@utils/misc.js';

export function _isValidFilter(filter) {
  if (filter === undefined) return false;
  if (Array.isArray(filter)) return filter.length !== 0;
  if (typeof filter === 'object' && filter !== null) {
    return Object.getOwnPropertySymbols(filter).findIndex((s) => filter[s] !== undefined) !== -1;
  }
  return true;
}

function massageFilterValue(value, attribute) {
  const parsedValue = ensureJSON(value);
  if (parsedValue !== null && typeof parsedValue === 'object' && !Array.isArray(parsedValue)) {
    const mappedObj = {};
    Object.entries(parsedValue).forEach(([opKey, opValue]) => {
      if (!(opKey in Op)) throw new Error(`Unknown operator ${opKey} for field ${attribute.name}`);
      mappedObj[Op[opKey]] = opValue;
    });
    return mappedObj;
  }
  if (!Array.isArray(parsedValue) || parsedValue.length !== 2) return parsedValue;
  // We special case arrays of the form [a, b] here as we may want to do a BETWEEN a AND b filter
  if (['FLOAT', 'INTEGER'].includes(attribute.type.key)) return { [Op.between]: parsedValue };
  return parsedValue;
}

// Takes an object with filters, e.g. { a: 1, b: 2, c: undefined }
// Iterates through keys and removes any with undefined value.
// Returns a *new* object - { a: 1, b: 2 } for the example above.
export function sanitizeFilters(filtersObj, modelName) {
  const { rawAttributes: attributes } = models[modelName];
  const knownAttributes = Object.keys(attributes);
  const sanitizedFilters = {};
  const unknownFields = [];
  Object.entries(filtersObj).forEach(([attrName, value]) => {
    if (!knownAttributes.includes(attrName)) {
      unknownFields.push(attrName);
      return;
    }
    const massagedValue = massageFilterValue(value, attributes[attrName]);
    if (_isValidFilter(massagedValue)) sanitizedFilters[attrName] = massagedValue;
  });
  if (unknownFields.length)
    logError(new Error(`Unknown ${modelName} field(s): [${unknownFields.join(', ')}], ignoring!`));
  return sanitizedFilters;
}

// Helper function to validate descriptors, takes descriptor and model it should fit
// Goes through model's raw attributes and verifies if descriptor has values
// for anything that is required.
// Returns an error string if any issue found, null otherwise
export function _validateDescriptor(descriptor, model) {
  const missingAttrs = [];
  Object.entries(model.rawAttributes).forEach(([key, attr]) => {
    if (attr._autoGenerated) return;
    if (attr.allowNull !== false || attr.defaultValue !== undefined) return;
    const val = descriptor[key];
    if (val === null || val === undefined) missingAttrs.push(key);
  });
  return missingAttrs.length ? `${missingAttrs.join(', ')} required` : null;
}
